// It contains all the queries I will be practicing .

1. How many users are active ?

Solution :

[
  {
    $match: {
      isActive : true
    }
  },
  {
    $count: 'activeUsers'
  }
]

2. What is the average age of all users ?

Solution : (Use $group whenever you need to summarize, calculate, or combine data across multiple documents — rather than look at each document individually.)

[
	{
	  $group: {
	    _id: null, // null bcz we want all users
	    average: {
	      $avg: "$age" 
	    }
	  }
	} 
]

3. List the top 5 most common favourite fruits among the users .

Solution : (3 aggregation pipelines used)
    1. To filter the users based on favoriteFruit
    2. Sorting the users based on favoriteFruit
    3. Find the top 'k' based on above pipelines

[
  {
    $group: {
    _id: "$favoriteFruit", // here $favoriteFruit is the group key 
    count:{     // here count is the field , sum is accumulator 
      $sum:1    // increases value by one everytime the favoriteFruit is found
    }
    }
  },
  {
    $sort: {
      count: -1 // -1 for descending order , 1 for ascending
    }
  },
  {
    $limit: 3 // when we want to find top 3 
  }
]

4. Find the total number of males and females. (I have sorted them as well)

Solution : 

[
  {
    $group: {
      _id: "$gender",
      Count: {
        $sum: 1
      }
    }
  },
  {
    $sort: {
      Count: 1
    }
  }
]

5. Which country has the highest number of registered user ?

Solution : Used three aggregation pipelines 
(company is an object then used '.' operator , then sort them , then found the highest)

[
  {
    $group: {
      _id: "$company.location.country",
      count: {
        $sum: 1,
      },
    },
  },
	{
	  $sort: {
	    count: -1 // for highest
	  }
	},
  {
    $limit: 1
  }
]

6. List all the eye colors present in the collection .(then sorted them as well in descending order)

Solution :

[
  {
    $group: {
      _id: "$eyeColor",
      count: {
        $sum: 1,
      },
    },
  },
	{
	  $sort: {
	    count: -1
	  }
	}
]

7. What is the average number of tags per user ?

Approach 1:

Pipeline:1 - (unwind means : This deconstructs the tags array, creating a new document for each tag.)
Pipeline:2 - First $group : Regroups by _id, counting how many tags each document had (using $sum: 1).
Pipeline:3 - Second $group : Calculates the average of numberOfTags across all documents.

[
  {
    $unwind: {
      path: "$tags",
    }
  },
  {
    $group: {
      _id: "$_id",
      numberOfTags:{
        $sum:1
      }
    }
  },
  {
    $group: {
      _id: null,
      avgNumberOfTags: {
        $avg: "$numberOfTags"
      }
    }
  }
]

Approach 2:

Pipeline:1 - $addFields : Adds a field numberOfTags that equals: The size of the tags array, or 0 if tags is missing or null.

Pipeline:2 - $group : Averages the numberOfTags across all documents.

[
  {
    $addFields: {
      numberOfTags: {
        $size:{
          $ifNull:["$tags",[]]
        }
      }
    }
  },
  {
    $group: {
      _id: null,
      avgTags: {
        $avg: "$numberOfTags"
      }
    }
  }
]

Conclusion :

    Use $unwind ➜ when you want the average only among docs that have at least one tag.
    Use $size + $ifNull ➜ when you want the average across all docs, treating missing tags as 0.


8 : How many users have 'enim' as one of their tags ?

Solution :

Pipeline:1 - This stage filters documents where tags contains the value "enim".
  If tags is an array, MongoDB automatically matches documents that contain "enim" as one of the elements.

Pipeline:2 - 
  Counts the number of documents that passed through $match.
  The output will be a single document with one field.

[
  {
    $match: {
      tags:"enim"
    }
  },
  {
    $count: 'UserWithEnimTag'
  }
]

9 : What are the names and age of the users who are inactive and have 'velit' as a tag ?

Solution :

Pipeline:1 - $match Stage : filters documents based on two conditions:
    isActive must be false
    tags array must contain the value "velit"

Pipeline:2 - $project Stage : selects only the name and age fields.
    _id is included by default, unless explicitly excluded.
    If you don’t want _id, you’d write: {
    $project: {
    _id: 0,
    name: 1,
    age: 1
    }
  }

[
  {
    $match: {
      isActive:false,
      tags:"velit"
    }
  },
  {
    $project: {
      name:1,
      age:1
    }
  }
]

10 : How many users have a phone number starting with '+1(940)' ?

Solution : (regex can be generated from ChatGPT)

[
  {
    $match: {
      "company.phone": /^\+1 \(940\)/
    }
  },
  {
    $count: 'numbers'
  }
]

11 : Who has registered most recently ?

Solution :

[
  {
    $sort: {
      registered: -1
    }
  },
  { $limit: 3 } ,
  {
    $project: {
      name:1,
      registered:1,
      favoriteFruit:1,
      _id:0
    }
  }
]

12 : Categorize users by their favourite fruit.

Solution : $group Stage does two main things :

  1. Groups documents by favoriteFruit
          Each unique value of favoriteFruit becomes a separate group (like a GROUP BY in SQL).

  2. Creates an array of all names belonging to that fruit.
          $push appends each person’s name field into an array for that fruit.

[
  {
    $group: {
      _id: "$favoriteFruit",
      users: {
        $push:"$name"
      }
    }
  }
]

13. How many users have 'ad' as the second tag in their list of tags ?

Solution :

[
  {
    $match: {
      "tags.1" : "ad"
    }
  },
  {
    $count: 'NumberOfAdtags'
  }
]

14. Find users who have both 'enim' and 'id' as their tags .

Solution :

The $all operator checks that the tags array contains both "enim" and "id" (in any order).
It means : Only documents that have all specified elements inside the tags array will pass.

Key Points :

Operator:               	Purpose:	                                          Example:
$all	    Matches arrays containing all specified elements	      { tags: { $all: ["enim", "id"] } }
$in	  Matches arrays containing any of the specified elements     { tags: { $in: ["enim", "id"] } }

[
  {
    $match: {
      tags:{
        $all:["enim","id"]
      }
    }
  },
  {
    $count: 'Fetched'
  }
]

15. List all the companies located in USA with their corresponding user count 

Solution :

Pipeline : 1 ->
$match Stage : Filters documents where the nested field company.location.country equals "USA".

Pipeline : 2 ->
$group Stage : 
-> Groups all documents (from the USA) by their company title.
-> $sum: 1 means: count how many users belong to each company.
So:
_id = company name
userCount = number of users in that company (who are in the USA)

[
  {
    $match: {
      "company.location.country" : "USA"
    }
  },
  {
    $group: {
      _id: "$company.title",
      userCount : {$sum:1}
    }
  }
]

Lookup examples :

Ex:1 =>

[
  {
    $lookup: {
      from: "authors",
      localField: "author_id",
      foreignField: "_id",
      as: "author_details"
    }
  },
  {
    $addFields: {
      author_details: {
        $first: "$author_details"
      }
    }
  }
]

Ex:2 =>

[
  {
    $lookup: {
      from: "authors",
      localField: "author_id",
      foreignField: "_id",
      as: "author_details"
    }
  },
  {
    $addFields: {
      author_details: {
        $arrayElemAt:["$author_details",0]
      }
    }
  }
]